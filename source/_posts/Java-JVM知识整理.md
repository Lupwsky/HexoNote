---
title: Java-JVM知识整理
date: 2019-05-20 22:57:45
categories: Java
---

# JVM 运行时分区

程序计数器, 方法区, 堆区, 栈, 本地方法栈

# 程序计数器

当前线程执行的字节码指令的地址, 如果执行的是原生的 (Native) 方法, 计数器的值为空, 每个线程都有一个程序计数器, 也是唯一一个没有定义 OutMemoryException 异常的区域

# 堆区 

所有线程共享, 所有对象和数组都在堆区分配, 初始堆区为物理机内存的 1/64, 最大堆区为物理机内存的 1/4, 可通过 -Xmx, -Xms 调整, 此区域会出现 OutMemoryException 异常
* 堆区又分为新生代, 老年代和持久代
* 新生代可以使用 -Xmn 来调整, 或者使用 -XX:NewSize, 最大值使用 -XX:MaxNewSize 来调整
* 持久代可以通过 -XX:PermSize 设置, 最大值可以通过 -XX:MaxPermSize 设置
* 老年代没有可设置的参数, 可以通过设置新生代和持久代的大小来设置
* 新生代和老年代还可以通过 -XX:NewRatio 来设置比例, 例如 -XX:NewRatio = 4, 表示新生代和老年代的比例为 1:4
* 新生代由 Eden Space, Survivor 0 Space, Survivor 1 Space 三个区域组成, 这三个区域默认占比为 8:1:1, 可以通过 -XX:SurvivorRatio 来设置比例, 例如 -XX:SurvivorRatio = 8, 表示两个 Survivor Space : Eden Space = 2 : 8

<!-- more -->

# 方法区

存放类的加载的信息

# 栈和本地方法栈

线程调用的方法

# GC 算法

* 标记-清除算法, 容易产生碎片
* 标记-整理算法, 解决标记-清除算法容易产生碎片的缺点, 需要移动元素, 性能稍低
* 复制算法, 分成两个相同大小的区域, 需要不需要清除的对象整理并移动到另一个区域, 完成后清除当前区域, 效率高, 但是浪费空间

# 分代 GC 算法

* 不同的区域使用不同的算法, 新生代使用复制算法, 老年代使用标记整理算法
* 新生代绝大部分的对象都是 "朝生夕死", 真正能存活下来的对象比较少, 为了不浪费空间, 新生代分成了 Eden Space, Survivor 0 Space, Survivor 1 Space 三个区域, 每次使用 Eden Space 和一个 Survivor 区, 当需要进行 GC 时, 将 Eden Space 和当前使用的 Survivor 区中存活的对象复制到另一个 Survivor 区, 然后直接清除 Eden Space 和 Survivor Space, 这样可以大大提高空间使用率, 被浪费的空间最多为 10% (默认占比 1:1:8), 如果存活的对象占用的内存大于 Survivor Space, 这些对象就会直接放入老年代中, 如果老年代空间不够, 就会进行一次 Major GC, 如果还是不够就会出现 OOM 异常

# 对象何时进入老年代

* 一般的对象在经过一定的年龄后, 会被移动到老年代, 这个年龄是经过 N 次 Minor GC 后还存活的对象, 默认是 15 次, 可以通过 -XX:MaxTenuringThreshold 设置
* 进行 Minor GC 时, 如果存活的对象占用的内存大于 Survivor Space 的空间, 所有的对象会被直接放入老年代
* 在新生代创建大对象时会直接放入老年代, 可以通过设置 -XX:PretenureSizeThreshold 设置这个值


# 常见垃圾回收器类型

* 串行 (Seial) 回收器, 单线程回收器, 简单, 易实现, 效率高, 也是默认的回收器
* 并行 (ParNew) 回收器, 串行回收器的多线程版本, 能有效利用 CPU, 减少回收时间
* 吞吐量优先 (Parallel) 回收器, 侧重于吞吐量的控制
* 并发标记清除 (CMS) 回收器, 最少回收停顿, 是基于标记清除算法实现的, 通常用于老年代的回收
* G1 回收器, 基于分区算法